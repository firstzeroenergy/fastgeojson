---
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fastgeojson <img src="man/figures/logo.png" align="right" height="138" />

**High-performance GeoJSON and JSON serialization for R**

`fastgeojson` provides fast conversion of `sf` objects to GeoJSON FeatureCollections and generic R objects (`data.frame`, lists, vectors) to JSON strings.

Implemented in Rust via the **extendr** framework, it uses parallel processing and low-level optimizations to deliver **2.4–16× speedups** over existing R solutions on large datasets.

The resulting strings are ready for use in web applications (Shiny, Plumber), direct integration with `leaflet::addGeoJSON()`, and other R packages that interface with JavaScript.

> **Status: v0.2.1** — Adds the auto_unbox argument to as_json(), giving users explicit control over whether single-element vectors are serialized as JSON scalars or arrays.

## Performance Benchmarks

Benchmarks conducted with `microbenchmark` (times in milliseconds; lower is better).

### JSON serialization: 1 million rows × 4 mixed columns

```{r json-bench, echo=FALSE}
data.frame(
  Package     = c("jsonify", "jsonlite", "yyjsonr", "fastgeojson"),
  Median_ms   = c(1573, 1281, 235, 98),
  `Speedup vs jsonlite` = c("—", "—", "5.5×", "13.1×")
) |> 
  knitr::kable()
```

### GeoJSON serialization: 1 million point features

```{r geojson-bench, echo=FALSE}
data.frame(
  Package     = c("geojsonsf", "yyjsonr", "fastgeojson"),
  Median_ms   = c(1920, 586, 238),
  `Speedup vs geojsonsf` = c("—", "3.3×", "8.1×")
) |> 
  knitr::kable()
```

## Correctness & Compatibility

The `as_json()` function is designed to replicate the behavior of the default settings of `jsonlite::toJSON()`.

While exact parity cannot be guaranteed for every possible input permutation, `fastgeojson` has been benchmarked against `jsonlite` across a diverse set of complex scenarios. In all tested cases below, the outputs are identical.

| Case | Output (Identical for both) | Match? |
| :--- | :--- | :--- |
| **Simple Numeric** | `[{"x":1},{"x":2.5},{"x":-3}]` | ✅ |
| **Integer NA** | `[{"x":1},{},{"x":3}]` | ✅ |
| **Double Special** | `[{"x":1},{},{},{},{}]` | ✅ |
| **Logical NA** | `[{"x":true},{"x":false},{}]` | ✅ |
| **Character NA** | `[{"ch":"foo"},{},{"ch":"NA"},{"ch":""}]` | ✅ |
| **Factor NA** | `[{"x":"a"},{"x":"b"},{},{"x":"NA"},{"x":"a"}]` | ✅ |
| **Mixed Types** | `[{"i":1...},{"ch":""},{"i":3...}]` | ✅ |
| **Dates** | `[{"d":"2020-01-01"},{},{"d":"2020-01-03"}]` | ✅ |
| **POSIXct** | `[{"dt":"2020-01-01 00:00:00"}...]` | ✅ |
| **Empty Rows** | `[]` | ✅ |
| **Empty Cols** | `[{},{},{}]` | ✅ |
| **Special Chars** | `[{"sp ace":1,"quote\"here":"a"}...]` | ✅ |
| **List Column** | `[{"id":1,"nested":[{"a":1,"b":"x"}]}...]` | ✅ |
| **List Atomic** | `[{"id":1,"vals":[1,2,3]}...]` | ✅ |
| **Row Names** | `[{"x":1,"y":"a","_row":"r1"}...]` | ✅ |

## Installation

### From CRAN (Recommended)
Once available on CRAN, you can install the stable version directly:
```r
install.packages("fastgeojson")
```

### Development Version (R-universe)
To install the latest development version or pre-compiled binaries for Windows/macOS (no Rust required) before the CRAN release:

```r
options(repos = c(
  firstzero = "https://firstzeroenergy.r-universe.dev",
  CRAN = "https://cloud.r-project.org"
))
install.packages("fastgeojson")
```

## Deploying to shinyapps.io

**Note:** If you are using the CRAN version, deployment works automatically.

If you are using the **development version** from R-universe, you must tell shinyapps.io where to find the package. 
**The Fix:** Add the following lines to the very top of your `app.R` (or `global.R`) file.

```r
options(repos = c(
  firstzero = "https://firstzeroenergy.r-universe.dev",
  CRAN = "https://cloud.r-project.org"
))
```
This ensures the build server can find and install `fastgeojson` from the custom repository.

## Main Features of the Rust Implementation

The core performance advantages come from a carefully designed Rust backend:

- **Parallel chunked processing**: Data is split into chunks (~2048 rows) and processed in parallel across all CPU cores using `rayon`.
- **Zero-overhead number formatting**: Floating-point numbers are written directly to the output buffer using `ryu::raw`—eliminating the temporary stack copies found in standard libraries—while integers are handled via `itoa` for maximum serialization throughput.
- **Thread-safe column preparation**: Attributes are pre-processed into thread-safe structures (String Arenas, cached factors) to allow concurrent access without R API calls.
- **Direct access to R vector data**: Uses raw pointers to R’s internal vectors (INTEGER, REAL, etc.) to avoid copying.
- **Efficient Geometry Flattening**: Complex, deeply nested `sf` objects are reorganized into simple, flat arrays before processing. This bypasses the heavy overhead of navigating R list structures, allowing specialized writers to serialize millions of coordinates in a single, high-speed pass.

These low-level optimizations eliminate the bottlenecks found in general-purpose JSON libraries while preserving full compatibility with R's data model.

## Core API

The package provides a single, unified entry point for all serialization:

- **`as_json(x, auto_unbox = FALSE)`**: The "omnivore" function. It automatically detects the input type (`sf` object, data frame, list, or vector) and dispatches it to the optimized Rust encoders.
    - *Arguments:* `auto_unbox`: If `TRUE`, atomic vectors of length 1 are automatically unboxed into scalar values (e.g., `[1]` becomes `1`).
    - *Returns:* A character string with class `json` (and `geojson` if applicable).
    - *Behavior:* Designed as a drop-in replacement for `jsonlite::toJSON()`, but significantly faster.

> **Note:** The low-level functions `sf_geojson_str()` and `df_json_str()` are still available for direct dispatch, but `as_json()` is recommended for all standard workflows.

## Usage Examples

### 1. Spatial Data (`sf` objects)
`fastgeojson` automatically detects `sf` objects and outputs standard GeoJSON FeatureCollections.

```r
library(sf)
library(fastgeojson)

nc <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)

# Automatically encoded as GeoJSON
json_out <- as_json(nc)

class(json_out)
#> [1] "geojson" "json"

# Ready for Leaflet (no additional conversion needed)
library(leaflet)
leaflet() %>%
  addTiles() %>%
  addGeoJSON(json_out)
```

### 2. Tabular Data (Data Frames)
Data frames are serialized as a JSON array of objects (row-oriented), optimized for web APIs.

```r
df <- data.frame(
  id = 1:2,
  name = c("Alice", "Bob"),
  score = c(98.5, NA)
)

json_out <- as_json(df)

class(json_out)
#> [1] "json"

json_out
#> [{"id":1,"name":"Alice","score":98.5},{"id":2,"name":"Bob"}]
```

### 3. General R Objects & Auto-Unboxing
Designed to behave similar to `jsonlite` for standard R structures, preserving types and hierarchies.

```r
# Default behavior (auto_unbox = FALSE)
as_json(list(val = 5), auto_unbox = FALSE)
#> {"val":[5]}

# With unboxing (auto_unbox = TRUE)
as_json(list(val = 5), auto_unbox = TRUE)
#> {"val":5}

# Nested lists
data <- list(
  meta = list(version = "1.0"),
  payload = c(10, 20)
)
as_json(data, auto_unbox = TRUE)
#> {"meta":{"version":"1.0"},"payload":[10,20]}
```

## Integration with Shiny

Because `fastgeojson` returns pre-classed `json` strings, you can bypass R's internal serialization when sending data to the browser.

```r
# FAST: Direct handoff to Leaflet or deck.gl
observe({
  # Use the generic encoder
  json_data <- as_json(large_sf_object)
  
  # Sent directly to client without re-encoding
  session$sendCustomMessage("updateMap", json_data)
})
```

## Supported Features

`fastgeojson` v0.2.1 supports serialization for a wide range of R data types:

- **Geometries:** Native support for all `sf` geometry types (POINT, MULTIPOINT, LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON) and GeometryCollections.
- **Atomic Vectors:** Integer, Double, Logical, Character, Factor.
- **Complex Structures:** List-Columns, Nested Lists, Matrices, and Data Frames (recursive serialization).
- **Dates / POSIXt:** Automatically formatted as character strings (e.g., `"2024-01-01"`) to ensure preservation of time zones and formats.
- **Missing values:** Handled contextually to preserve structure.
  - **Data Frames:** Fields with `NA` are **omitted** (creating sparse objects) to reduce payload size.
  - **Vectors/Lists:** `NA` values are converted to `"NA"` strings (e.g., `[1, "NA", 3]`) to preserve strict array length.

## Development

- Rust implementation: `src/rust/` (managed via `rust-toolchain.toml` for reproducible builds)
- R interface: `R/`
- Built with **extendr**

Bug reports, feature requests, and contributions are very welcome

## License

MIT © FirstZero Energy
